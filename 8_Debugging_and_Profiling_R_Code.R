##Debugging###
#``````````````````````````````#

#What's wrong

#message: A generic notification/diagnostic message produced by the message() function; execution of the function continues
#warning: An indication that something is wrong but not necessarily fatal; execution of the function continues. Warnings are generated by the warning() function
#error: An indication that a fatal problem has occurred and execution of the function stops. Errors are produced by the stop() function.
#condition: A generic concept for indicating that something unexpected has occurred; programmers can create their own custom conditions if they want.

#example of a warning
x<-log(-1)

printmessage <- function(x) {
  if(x > 0)
    print("x is greater than zero")
  else
    print("x is less than or equal to zero")
  invisible(x) #the return value doesn't get autoprinted
}
printmessage(1)
printmessage(NA)

##What happened
printmessage2 <- function(x) {
  if(is.na(x))
    print("x is a missing value!")
  else if(x > 0)
    print("x is greater than zero")
  else
    print("x is less than or equal to zero")
  invisible(x)
}
printmessage2(NA)

x <- log(c(-1, 2))
printmessage2(x)

#What happened: We called a vector
printmessage3 <- function(x) {
  if(length(x) > 1L)
    stop("'x' has length > 1")
  if(is.na(x))
    print("x is a missing value!")
  else if(x > 0)
    print("x is greater than zero")
  else
    print("x is less than or equal to zero")
  invisible(x)
}
printmessage3(1:2)

#WHt happened: Vectorizing the function can be accomplished easily with the Vectorize() function.
printmessage4 <- Vectorize(printmessage2)
out <- printmessage4(c(-1, 2))

##Figuring Out What’s Wrong
#````````````````````````````````

#What was your input? How did you call the function?
#What were you expecting? Output, messages, other results?
#What did you get?
#How does what you get differ from what you were expecting?
#Were your expectations correct in the first place?
#Can you reproduce the problem (exactly)?


##Debugging Tools in R
#`````````````````````````````````````````````##

#traceback(): prints out the function call stack after an error occurs; does nothing if there’s no error
#debug(): flags a function for “debug” mode which allows you to step through execution of a function one line at a time
#browser(): suspends the execution of a function wherever it is called and puts the function in debug mode
#trace(): allows you to insert debugging code into a function a specific places
#recover(): allows you to modify the error behavior so that you can browse the function call stack

#using traceback()
rm(list = ls())
mean(x)
traceback()

lm(y ~ x)
traceback()

##Using debug()
#The debug() function initiates an interactive debugger (also known as the “browser” in R) for a function. 

debug(lm) ## Flag the 'lm()' function for interactive debugging
lm(y ~ x)
#n executes the current expression and moves to the next expression
#c continues execution of the function and does not stop until either an error or the function exits
#Q quits the browser
undebug(lm) ## Unflag the 'lm()' function for debugging

###Using recover()
#The recover() function can be used to modify the error behavior of R when an error occurs.
options(error = recover) ## Change default R error behavior
read.csv("nosuchfile") ## This code doesn't work


###Summary
###``````````````````````````````````
#• There are three main indications of a problem/condition: message, warning, error; only an error is fatal
#• When analyzing a function with a problem, make sure you can reproduce the problem, clearly state your expectations and how the output differs from your expectation
#• Interactive debugging tools traceback, debug, browser, trace, and recover can be used to find problematic code in functions
#• Debugging tools are not a substitute for thinking!



####Profiling R Code####
#``````````````````````#
##Let’s solve the problem but let’s not make it worse by guessing. —Gene Kranz, Apollo Lead Flight Director##
#
########DESIGN>>>OPTIMISE>>>MEASURE/COLLECT DATA (Don't Guess!!)
#
##We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil —Donald Knuth


###Using system.time()
#The system.time() function takes an arbitrary R expression as input  and returns the amount of time taken to evaluate the expression. The system.time() function
#computes the time (in seconds) needed to execute an expression and if there’s an error, gives the time
#until the error occurred. The function returns an object of class proc_time which contains two useful
#bits of information:
#• user time: time charged to the CPU(s) for this expression
#• elapsed time: “wall clock” time, the amount of time that passes for you as you’re sitting there

## Elapsed time > user time
system.time(readLines("http://www.jhsph.edu"))

##Elapsed time < user time
hilbert <- function(n) {
  i <- 1:n
  1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))

##Timing Longer Expressions
#You can time longer expressions by wrapping them in curly braces within the call to system.time().
system.time({
  n <- 1000
  r <- numeric(n)
  for(i in 1:n) {
    x <- rnorm(n)
    r[i] <- mean(x)
  }
})

##The R Profiler
Rprof() ### Turn on the profiler
Rprof(NULL) ## Turn off the profiler
############DOn't use system.time and rprof together

##Using summaryRprof()
#The summaryRprof() function tabulates the R profiler output and calculates how much time is spend
#in which function. There are two methods for normalizing the data.
#• “by.total” divides the time spend in each function by the total run time
#• “by.self” does the same as “by.total” but first subtracts out time spent in functions above the
#current function in the call stack. I personally find this output to be much more useful.

$by.total


#The final bit of output that summaryRprof() provides is the sampling interval and the total runtime.
#$sample.interval
#$sampling.time



#####Summary
#• Rprof() runs the profiler for performance of analysis of R code Profiling R Code 122
#• summaryRprof() summarizes the output of Rprof() and gives percent of time spent in each function (with two types of normalization)
#• Good to break your code into functions so that the profiler can give useful information about where time is being spent
#• C or Fortran code is not profiled




